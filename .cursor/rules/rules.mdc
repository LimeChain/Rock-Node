---
description: 
globs: 
alwaysApply: true
---
# .cursorrules for the Rock Node Project
# This file guides the AI and developers to adhere to the architectural
# principles established in the Software Design Document.

# general-instructions provide the high-level context and core principles for the AI.
general-instructions:
  - role: user
    content: |
      You are an expert Rust developer working on the "Rock Node" project.
      The Rock Node is a high-performance, decentralized data availability layer for the Hiero network.

      **Core Technologies:**
      - **Language:** Rust (2021 Edition or later)
      - **Asynchronous Runtime:** Tokio
      - **gRPC:** Tonic
      - **HTTP Server (for Observability):** Axum or Hyper
      - **Configuration:** TOML files deserialized with Serde
      - **Database (Hot Tier):** RocksDB
      - **Logging:** `tracing` crate for structured (JSON) logging.
      - **Metrics:** `metrics` crate facade with a Prometheus exporter.

      **Key Architectural Principles (MUST be followed):**
      1.  **Plugin-Based Architecture:** The system is composed of a lightweight core and independent 'Plugins'. Every major feature (e.g., Persistence, Verifier, gRPC services) MUST be implemented as a Plugin.
      2.  **Strict Decoupling:** Plugins MUST NOT call each other's code directly. They are completely isolated.
      3.  **Event-Driven Communication:** The primary way for plugins to interact is by publishing and subscribing to events on the central `Core Messaging` bus (which uses a lock-free ring buffer pattern). This is the preferred method for asynchronous, decoupled communication.
      4.  **Shared Context (`AppContext`):** For synchronous needs (like configuration or accessing a shared facility), plugins receive an `AppContext`. Plugins can register shared, abstract `Trait` implementations (like a `BlockReader`) into the `AppContext` for other plugins to use, but should not expose their concrete types.
      5.  **Capability Discovery:** Use the `CapabilityRegistry` pattern. A plugin registers its capabilities at startup, and other plugins query the registry to adapt their behavior.
      6.  **Error Handling:** Use Rust's `Result` type extensively. Create custom, specific error enums for each plugin. Avoid using `.unwrap()` or `.expect()` in application code; handle all errors gracefully.
      7.  **Asynchronous Everywhere:** All I/O operations (network, disk) must be `async` and non-blocking.

# rules define more specific, actionable instructions for code generation and modification.
rules:
  - when: "I ask to create a new service or major feature"
    then: |
      - Create a new Rust module for it under the `src/plugins/` directory.
      - Implement the `Plugin` trait (`src/plugins/mod.rs`).
      - Define a dedicated configuration struct for it and add a corresponding table to the `config.template.toml` file under `[plugins]`.
      - If it exposes a network endpoint (gRPC/HTTP), that logic must be contained within its `start()` method.
      - Register the new plugin in `src/main.rs`.

  - when: "I ask for two services to communicate"
    then: |
      - First, consider if the communication can be modeled asynchronously with events on the `Core Messaging` bus. This is the default choice.
      - If a synchronous query is absolutely necessary (e.g., fetching data on-demand), the service providing the data MUST expose its functionality via a `trait`. An implementation of this trait should be registered in the `AppContext`. The consuming service will then access the `trait` from the `AppContext`, not the concrete service.

  - when: "I ask to add logging or metrics"
    then: |
      - For logging, use the `tracing` crate macros (`info!`, `warn!`, `error!`, `debug!`). Ensure logs are structured by including key-value pairs. For example: `info!(block_number = 123, "Block persisted successfully");`
      - For metrics, use the `metrics` crate macros (`counter!`, `gauge!`, `histogram!`).

  - when: "I ask to handle configuration"
    then: |
      - All configuration should be defined in structs within a `config.rs` module, using Serde for deserialization from the main `config.toml` file.
      - Do not hardcode values; always add a new field to the appropriate config struct.

# file-rules tell the AI which files are most important for understanding the project's context.
file-rules:
  - rule: "Always be aware of the contents of these core files when providing code or suggestions."
    files:
      - path: "Cargo.toml" # Defines dependencies, features, and workspace structure.
        reason: "The manifest file is the source of truth for all project dependencies and features, which directly relates to our plugin architecture."
      - path: "src/main.rs" # The application entry point.
        reason: "This file shows how all plugins are composed and started, and how the AppContext is constructed. It's the master blueprint."
      - path: "src/plugins/mod.rs" # The definition of the Plugin trait.
        reason: "This trait is the fundamental contract for all modular components in the system."
      - path: "src/core/app_context.rs" # The definition of the AppContext struct.
        reason: "This struct defines all the shared facilities available to plugins. It's the key to inter-plugin access."
      - path: "src/core/messaging.rs" # The Core Messaging bus implementation.
        reason: "This is the primary communication channel. Understanding its API is crucial."
      - path: "config.template.toml" # The configuration template.
        reason: "This file shows all available configuration options for the core app and all its plugins."
      - path: "docs/architecture/sdd.md" # The Software Design Document we just created.
        reason: "This is the primary source of truth for all architectural decisions. Refer to it for high-level context."
      - path: "docs/architecture/adr/" # The directory containing our ADRs.
        reason: "This directory contains the formal records of *why* key decisions were made. It should be consulted to understand the rationale behind the architecture."